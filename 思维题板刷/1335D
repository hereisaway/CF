纯智力题。很难，但又很简单

给出一个合法的数独，修改九个数，使数独的规则完全被破坏，每一行，每一列和每一格内都有至少两个相同元素。
很容易想到爆搜，但估计一下状态数，一共9个数可以修改，每次修改都有8个数字，81个位置可选，总状态数大约是（8 * 81） ^ 9，完全没有可行性
这种题不可能让我们爆搜的，否则这就是一道搜索题了，而这实际上是一道数学题或者说思维题。

这种题的关键是从性质出发，仔细想想，我们一共可以改九次，要使9行，9列，9格都被破坏。而每次最多只能破坏一行，一列和一格，因此我们必须每次都恰好破坏一行一列和一格。
想要破坏一行，就必须把这个数改成这一行里已经存在的某个数，破坏一列和一格同理。现在的问题是，我们修改成什么数才能保证每次修改时同一行，同一列和同一格都一定有一个和修改后数相同的数呢？
注意，初始状态是一个合法的数独，这个性质我们还没用上。合法的数独已经保证了，任选一个位置，这个格子上的数为y，那么对于不为y的任意x,这个位置所在行，列和格都只有1个x，
因此我们直接把y修改成x，就可以使该位置所在行、列和格都有两个x，实现了改一个数破坏一行，一列和一格。
接下来还有个问题是，不同修改可能破坏同一行，同一列或同一格，这样就又不能保证每次修改都恰破坏一行一列一格了。
想要避免这一点，我们就需要每次修改的位置都位于不同行，列和格，这样他们的影响就不会叠加。
那么我们怎么找到9个格子，保证他们不位于同一行，同一列和同一格呢？再次回到合法数独的性质，任选一个数x，合法数独中的9个x一定是位于不同行，不同列和不同格的。

因此，我们任选一个数x，将原始合法数独中所有x都修改成另一个数y，就可以实现题目的要求了。
这道题的教训是，第一，重视性质，一方面，性质都不是白给的，肯定要用上，比如合法数独的性质，另一方面，很多看似复杂的问题，其实从性质出发就能很简单的解决
，但如果忽视性质则是做不出来的。第二，构造题是数学题，不要想着借助计算机的算力解决，核心部分都是人脑想出来的。很多结论，用人脑可以很快推出来，但如果暴力可能要算100年。
第三，构造题的结果往往比想象中简单，不要想太复杂，要敢想。
#include<bits/stdc++.h>
using namespace std;
#define db double
#define ll long long
#define rep1(i,x,y) for(int i=(x);i<=(y);i++)
#define rep2(i,x,y) for(int i=(x);i>=(y);i--)
#define inf 0x3f3f3f3f
const int N=1e5+10;
ll rd(void){
	ll x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
const int mod=1e6;
char a[10][10];
int main(){
	int t=rd();
	while(t--){
		rep1(i,1,9)
			scanf("%s",a[i]);
		rep1(i,1,9){
			rep1(j,0,8){
				if(a[i][j]=='2')cout<<'1';
				else cout<<a[i][j];
			}
			cout<<endl;
		}
	}
}

