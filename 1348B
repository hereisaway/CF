思维题真的很美。

给出一个长n的数列，要求在数列中添加一些1-n内的数，使修改后的数列的所有长度为k的子列元素和都相等，并且要求添加后的数列长度不超过nk。
关键在于你对“所有长度为k的子列元素和都相等”够不够敏感，数学直觉好的人可能一眼就能看出这是元素以k为周期的意思。
具体证明也很好证，sum（ai,aj）表示ai，到aj的和，如果所有长度为k的子列长度都相等，则有sum(ai,ai+k-1)=sum(ai+1,ai+k)，因此ai=ai+k，而i是任取的，这就证明了这个序列以k为周期。

因此问题就转化成了如何把原始数列加入一些数，使其成为以k为周期的周期序列，并且由于要应对多组案例，最好有一种通用的方法。
实际上，一种通用的方法是，先找到原始数列中出现的数字，让他们以任意顺序，不重复地组成一个序列，如果此时长度不到k，在任意位置补1，直到其长度为k。
最后把这个序列重复n次，就是我们想要的，一个可以由原始数列添加数字得到的，周期为k，长度不超过nk的数列。

它周期为k是显然的，因为他就是一个长度为k的数列重复形成的。而它能由原数列加数形成其实也很好证明，对于原数组中的第i个数，我们可以在最终数组的第i个周期中找到他，
因为每个周期都包含了原始数组中每个独立的数字。也就是说我们可以在最终数组中，每个周期取一个数，按顺序拼在一起，组成原数组。那么只要把最终数组中多出来的那些数填进原始数组中，就能组成最终数组了。
最后，这个数组的长度为nk,刚好没超范围。

这题就是典型的构造题，构造题的特点是，正面求出解很困难，甚至完全没有思路。
但是如果分析题目要求的结果应该满足什么性质，然后根据这些性质构造一个结果，再证明这个结果可以由初始条件推出来，往往就很简单。
也就是说先构造，再证明，这里唯一的难点就是构造，想不到的话就是想不到，能想到的话可以很快想到，然后证明就简单了。
构造一个答案，往往考验的是直觉和天赋，他不是可以按部就班推导出来的，这也是为什么构造这么难。往往只有在明确了正面推推导推不出来，再考虑构造。
#include<bits/stdc++.h>
using namespace std;
#define db double
#define ll long long
#define rep1(i,x,y) for(int i=(x);i<=(y);i++)
#define rep2(i,x,y) for(int i=(x);i>=(y);i--)
#define inf 0x3f3f3f3f
const int N=1e5+10;
int rd(void){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int main(){
	int m=rd(),book[105];
	while(m--){
		int n=rd(),k=rd();
		int cnt=0;
		memset(book,0,sizeof book);
		rep1(i,1,n){
			int t=rd();
			book[t]=1;//统计原数组有哪些独立数字
		}
		rep1(i,1,n)
			cnt+=book[i]; //统计独立数字能构成的序列长度
		//cout<<"cnt:"<<cnt<<endl;
		if(cnt>k)cout<<"-1"<<endl;//如果独立数字大于k个，不可能组成周期为k的数列
		else{
			cout<<n*k<<endl;//构成数列长度为nk
			rep1(i,1,n){//重复n次
				rep1(j,1,n)if(book[j])cout<<j<<' ';//先让独立数字以任意顺序排列
				rep1(j,1,k-cnt)cout<<1<<' ';//如果此时长度不到k，用1补全
			}
			cout<<endl;
		}
	}
}

